<html>
  <head>
    <link rel="stylesheet" href="orbit/assets/css/style.css">
  </head>

  <body>
    

    <canvas id="canvas" width="3000" height="3000"></canvas>
    <script src="orbit/assets/data/data_obj.js"></script>
    <script src="orbit/assets/data/shope_0.js"></script>
    <script src="orbit/assets/data/shope_1.js"></script>
    <script src="orbit/assets/data/shope_2.js"></script>
    <script src="orbit/assets/data/shope_3.js"></script>



    <script src="beziertools.js"></script>
    <script src="SingleFontOnCanvas/SingleFontOnCanvas.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 55 Roman_data.js"></script>


    <script>
      
    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    ctx.webkitImageSmoothingEnabled = true;
    ctx.mozImageSmoothingEnabled = true;
    ctx.msImageSmoothingEnabled = true;
    ctx.oImageSmoothingEnabled = true;


    let shape_data_con = [shape_0, shape_1, shape_2, shape_3];


    // i think this is looping, it needs to add the initial path one additional time as the last path.
    for(let i = 0; i < shape_data_con.length; i++){
      let n = Object.assign({},shape_data_con[i].letters.path[2][0][0]);
      shape_data_con[i].letters.path[2][0].push(n)
    }


    function Shape_container_arr(shapes, num_of_points){

      let letter_canvas_path_con = [];
      let letter_canvas_path_con_1 = [];

      let bezier_points_con = [];

      let bezier_length = [];

      let divided_length_array_index = [];

      let points_position = [];

      let derivative_angle_con = [];

      let points_angle = [];
      

      for(let i = 0; i < shapes.length; i++){
      
        letter_canvas_path_con[i] = shapes[i].letters.path[2][0];

        for(let a = 0; a < letter_canvas_path_con[i].length; a++){
            letter_canvas_path_con[i][a].y = shapes[i].parameters.cap_height - letter_canvas_path_con[i][a].y;
            letter_canvas_path_con[i][a].in_y = shapes[i].parameters.cap_height - letter_canvas_path_con[i][a].in_y;
            letter_canvas_path_con[i][a].out_y = shapes[i].parameters.cap_height - letter_canvas_path_con[i][a].out_y;
        }

        // console.log(letter_canvas_path_con)

        bezier_points_con[i] = get_bezier_points(letter_canvas_path_con[i]);

        bezier_length[i] = get_bezier_length(bezier_points_con[i]);

        divided_length_array_index[i] = equally_divide_length(bezier_length[i].total_length, bezier_length[i].each_point_length, num_of_points);

        points_position[i] = get_points_position(bezier_points_con[i], divided_length_array_index[i]);

        derivative_angle_con[i] = derivative(bezier_points_con[i]);

        points_angle[i] = get_point_angle(derivative_angle_con[i], divided_length_array_index[i]);

        points_angle[i].pop();

        points_position[i].pop();

      }

      return {points_position, points_angle}
        
    }


    let shape_con = new Shape_container_arr(shape_data_con, 1000);

        
    let grid_con_1 = structuredClone(shape_con.points_position);

    
    let grid_con_2 = structuredClone(shape_con.points_position);


    let scale = 1.6;



    //changing the angles to be continuous tangent line
    for(let i = 0; i < shape_con.points_angle[3].length; i++){
        shape_con.points_angle[3][i] = shape_con.points_angle[3][i] * -1
    }

    // console.log(shape_con.points_angle[3])

    console.log(shape_con)

    for(let i = 0; i < shape_con.points_position.length; i++){
      for(let j = 0; j < shape_con.points_position[i].length; j++){

        grid_con_1[i][j] = calculateNewPosition(
            shape_con.points_position[i][j].x * scale, shape_con.points_position[i][j].y * scale, shape_con.points_angle[i][j], 200
        );

        grid_con_2[i][j] = calculateNewPosition(
            shape_con.points_position[i][j].x * scale, shape_con.points_position[i][j].y * scale, shape_con.points_angle[i][j], -200
        );

      }
    }
    



    function calculateNewPosition(x, y, angle, length) {
        // Convert angle from degrees to radians
        let radians = angle * (Math.PI / 180);

        // Calculate the new x and y positions
        let newX = x + length * Math.cos(radians);
        let newY = y + length * Math.sin(radians);

        return { x: newX, y: newY };
    }


    let assets = {
      position: {x: 100, y: 100},
      weight: 1,
      scale: 0.2,
      alignment: 'left',
      italic: false,
      sticky: undefined,
      color: undefined,
      line_height: undefined,
      tracking: undefined,
      kerning: undefined,
      stroke_width: 1,
      stroke_style: undefined,
      structure_width: 0,
      structure_style: undefined,
    }


    let letter_a_1 = new StaticSingleFontOnCanvas(Neue_Haas_Grotesk_Display_Pro_55_Roman, 'PassangersOnlyPlease', assets);


    function Get_Grid_based_Glyph(canvas_letter, num_of_points){
      
      let grid_info = {
        num_of_points: num_of_points,
        dist_btwn_points: null,
        point_con: [],
        // input_path_con: [],
        // grid_path_con: [],
      }


      //  Getting grid's dist_btwn_points
      if((canvas_letter.extreme_val.max - canvas_letter.position.x) > canvas_letter.total_width){
          grid_info.dist_btwn_points = (canvas_letter.extreme_val.max - canvas_letter.position.x) / grid_info.num_of_points;
      }else{
          grid_info.dist_btwn_points = canvas_letter.total_width / grid_info.num_of_points;
      }

      //  Populating points with x num of dist_btwn_points
      for(let i = 0; i <= grid_info.num_of_points; i++){
          grid_info.point_con[i] = {x: grid_info.dist_btwn_points * i , y: 0};
      }


      //  Finding points percentage within the grid for interpolation
      let path_pos_by_perc = structuredClone(canvas_letter.typeface_path_con);

      //  Finding which grid the points lies on
      let corresponding_grid_index = structuredClone(canvas_letter.typeface_path_con);


      for(let i = 0; i < canvas_letter.typeface_path_con.length; i++){
        for(let j = 0; j < canvas_letter.typeface_path_con[i].length; j++){
          for(let k = 0; k < canvas_letter.typeface_path_con[i][j].length; k++){

            for(let n = 0; n < grid_info.point_con.length - 1; n++){

              if(grid_info.point_con[n].x <= canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x && canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x < grid_info.point_con[n + 1].x){
                path_pos_by_perc[i][j][k].x = ((canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x) - grid_info.point_con[n].x) / grid_info.dist_btwn_points
                corresponding_grid_index[i][j][k].x = n;
              }

              if(grid_info.point_con[n].x <= canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x && canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x < grid_info.point_con[n + 1].x){
                path_pos_by_perc[i][j][k].in_x = ((canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x) - grid_info.point_con[n].x) / grid_info.dist_btwn_points
                corresponding_grid_index[i][j][k].in_x = n;
              }

              if(grid_info.point_con[n].x <= canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x && canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x < grid_info.point_con[n + 1].x){
                path_pos_by_perc[i][j][k].out_x = ((canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x) - grid_info.point_con[n].x) / grid_info.dist_btwn_points
                corresponding_grid_index[i][j][k].out_x = n;
              }

            }         


            if(grid_info.point_con[grid_info.point_con.length - 1].x == canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x){
              path_pos_by_perc[i][j][k].x = ((canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x) - grid_info.point_con[grid_info.point_con.length - 1].x) / grid_info.dist_btwn_points
              corresponding_grid_index[i][j][k].x = grid_info.point_con.length - 1;
            }

            if(grid_info.point_con[grid_info.point_con.length - 1].x == canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x){
              path_pos_by_perc[i][j][k].in_x = ((canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x) - grid_info.point_con[grid_info.point_con.length - 1].x) / grid_info.dist_btwn_points
              corresponding_grid_index[i][j][k].in_x = grid_info.point_con.length - 1;
            }

            if(grid_info.point_con[grid_info.point_con.length - 1].x == canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x){
              path_pos_by_perc[i][j][k].out_x = ((canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x) - grid_info.point_con[grid_info.point_con.length - 1].x) / grid_info.dist_btwn_points
              corresponding_grid_index[i][j][k].out_x = grid_info.point_con.length - 1;
            }


            path_pos_by_perc[i][j][k].y = (path_pos_by_perc[i][j][k].y - canvas_letter.position.y) / canvas_letter.total_height
            path_pos_by_perc[i][j][k].in_y = (path_pos_by_perc[i][j][k].in_y - canvas_letter.position.y) / canvas_letter.total_height
            path_pos_by_perc[i][j][k].out_y = (path_pos_by_perc[i][j][k].out_y - canvas_letter.position.y) / canvas_letter.total_height
        

            // y index is not needed, since the grid is the vertical grid.
            // keeping place holder for y to make the clone process simple, and potential future x&y grid text warp function
            corresponding_grid_index[i][j][k].y = null;
            corresponding_grid_index[i][j][k].in_y = null;
            corresponding_grid_index[i][j][k].out_y = null;

          }
        }
      }




        this.draw_grid = function(path){

          for(let j = 0; j < grid_con_1[path].length; j++){
                            
            // Start a new Path
            ctx.beginPath();
            ctx.moveTo(grid_con_1[path][j].x, grid_con_1[path][j].y);
            ctx.lineTo(grid_con_2[path][j].x, grid_con_2[path][j].y);
            
            // Draw the Path
            ctx.stroke();

          }

        }


        this.draw_letter = function(path){

          ctx.beginPath();

          for(let i = 0; i < path_pos_by_perc.length; i++){
            for(let j = 0; j < path_pos_by_perc[i].length; j++){

              ctx.moveTo(
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).x,
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).y
              );

              for(let k = 0; k < path_pos_by_perc[i][j].length - 1; k++){

                ctx.bezierCurveTo(
                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k].out_x + n], grid_con_2[path][corresponding_grid_index[i][j][k].out_x + 1 + n], path_pos_by_perc[i][j][k].out_x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k].out_x + n], grid_con_1[path][corresponding_grid_index[i][j][k].out_x + 1 + n], path_pos_by_perc[i][j][k].out_x),
                    path_pos_by_perc[i][j][k].out_y
                  ).x,
                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k].out_x + n], grid_con_2[path][corresponding_grid_index[i][j][k].out_x + 1 + n], path_pos_by_perc[i][j][k].out_x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k].out_x + n], grid_con_1[path][corresponding_grid_index[i][j][k].out_x + 1 + n], path_pos_by_perc[i][j][k].out_x),
                    path_pos_by_perc[i][j][k].out_y
                  ).y,

                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k + 1].in_x + n], grid_con_2[path][corresponding_grid_index[i][j][k + 1].in_x + 1 + n], path_pos_by_perc[i][j][k + 1].in_x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k + 1].in_x + n], grid_con_1[path][corresponding_grid_index[i][j][k + 1].in_x + 1 + n], path_pos_by_perc[i][j][k + 1].in_x),
                    path_pos_by_perc[i][j][k + 1].in_y
                  ).x,
                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k + 1].in_x + n], grid_con_2[path][corresponding_grid_index[i][j][k + 1].in_x + 1 + n], path_pos_by_perc[i][j][k + 1].in_x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k + 1].in_x + n], grid_con_1[path][corresponding_grid_index[i][j][k + 1].in_x + 1 + n], path_pos_by_perc[i][j][k + 1].in_x),
                    path_pos_by_perc[i][j][k + 1].in_y
                  ).y,

                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k + 1].x + n], grid_con_2[path][corresponding_grid_index[i][j][k + 1].x + 1 + n], path_pos_by_perc[i][j][k + 1].x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k + 1].x + n], grid_con_1[path][corresponding_grid_index[i][j][k + 1].x + 1 + n], path_pos_by_perc[i][j][k + 1].x),
                    path_pos_by_perc[i][j][k + 1].y
                  ).x,
                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k + 1].x + n], grid_con_2[path][corresponding_grid_index[i][j][k + 1].x + 1 + n], path_pos_by_perc[i][j][k + 1].x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k + 1].x + n], grid_con_1[path][corresponding_grid_index[i][j][k + 1].x + 1 + n], path_pos_by_perc[i][j][k + 1].x),
                    path_pos_by_perc[i][j][k + 1].y
                  ).y,
                );

              }

              ctx.bezierCurveTo(

                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + n], grid_con_2[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + 1 + n], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + n], grid_con_1[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + 1 + n], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_y
                ).x,
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + n], grid_con_2[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + 1 + n], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + n], grid_con_1[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + 1 + n], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_y
                ).y,

                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].in_x + n], grid_con_2[path][corresponding_grid_index[i][j][0].in_x + 1 + n], path_pos_by_perc[i][j][0].in_x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].in_x + n], grid_con_1[path][corresponding_grid_index[i][j][0].in_x + 1 + n], path_pos_by_perc[i][j][0].in_x),
                  path_pos_by_perc[i][j][0].in_y
                ).x,
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].in_x + n], grid_con_2[path][corresponding_grid_index[i][j][0].in_x + 1 + n], path_pos_by_perc[i][j][0].in_x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].in_x + n], grid_con_1[path][corresponding_grid_index[i][j][0].in_x + 1 + n], path_pos_by_perc[i][j][0].in_x),
                  path_pos_by_perc[i][j][0].in_y
                ).y,

                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).x,
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).y,

              );


              ctx.lineTo(

                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].x
                ).x,
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].y),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].y),
                  path_pos_by_perc[i][j][0].y
                ).y

              );

            }
          }

          ctx.fillStyle = "#ff0000";
          ctx.fill();
          ctx.closePath();

        }




      function interpolatePoint(point1, point2, t) {
        const x = (1 - t) * point1.x + t * point2.x;
        const y = (1 - t) * point1.y + t * point2.y;
        return {x: x, y: y};
      }


      console.log(grid_info)

      // return {grid_info, path_pos_by_perc, corresponding_grid_index}

    }

    
    let grid_letter = new Get_Grid_based_Glyph(letter_a_1, 800);




    function Get_Grid_based_Glyph_1(canvas_letter, num_of_points, shape_path){
      
      let grid_info = {
        num_of_points: num_of_points,
        dist_btwn_points: null,
        point_con: [],
        // input_path_con: [],
        // grid_path_con: [],
      }


      //  Getting grid's dist_btwn_points
      if((canvas_letter.extreme_val.max - canvas_letter.position.x) > canvas_letter.total_width){
          grid_info.dist_btwn_points = (canvas_letter.extreme_val.max - canvas_letter.position.x) / grid_info.num_of_points;
      }else{
          grid_info.dist_btwn_points = canvas_letter.total_width / grid_info.num_of_points;
      }

      //  Populating points with x num of dist_btwn_points
      for(let i = 0; i <= grid_info.num_of_points; i++){
          grid_info.point_con[i] = {x: grid_info.dist_btwn_points * i , y: 0};
      }


      //  Finding points percentage within the grid for interpolation
      let path_pos_by_perc = structuredClone(canvas_letter.typeface_path_con);

      //  Finding which grid the points lies on
      let corresponding_grid_index = structuredClone(canvas_letter.typeface_path_con);


      for(let i = 0; i < canvas_letter.typeface_path_con.length; i++){
        for(let j = 0; j < canvas_letter.typeface_path_con[i].length; j++){
          for(let k = 0; k < canvas_letter.typeface_path_con[i][j].length; k++){

            for(let n = 0; n < grid_info.point_con.length - 1; n++){

              if(grid_info.point_con[n].x <= canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x && canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x < grid_info.point_con[n + 1].x){
                path_pos_by_perc[i][j][k].x = ((canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x) - grid_info.point_con[n].x) / grid_info.dist_btwn_points
                corresponding_grid_index[i][j][k].x = n;
              }

              if(grid_info.point_con[n].x <= canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x && canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x < grid_info.point_con[n + 1].x){
                path_pos_by_perc[i][j][k].in_x = ((canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x) - grid_info.point_con[n].x) / grid_info.dist_btwn_points
                corresponding_grid_index[i][j][k].in_x = n;
              }

              if(grid_info.point_con[n].x <= canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x && canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x < grid_info.point_con[n + 1].x){
                path_pos_by_perc[i][j][k].out_x = ((canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x) - grid_info.point_con[n].x) / grid_info.dist_btwn_points
                corresponding_grid_index[i][j][k].out_x = n;
              }

            }         


            if(grid_info.point_con[grid_info.point_con.length - 1].x == canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x){
              path_pos_by_perc[i][j][k].x = ((canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x) - grid_info.point_con[grid_info.point_con.length - 1].x) / grid_info.dist_btwn_points
              corresponding_grid_index[i][j][k].x = grid_info.point_con.length - 1;
            }

            if(grid_info.point_con[grid_info.point_con.length - 1].x == canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x){
              path_pos_by_perc[i][j][k].in_x = ((canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x) - grid_info.point_con[grid_info.point_con.length - 1].x) / grid_info.dist_btwn_points
              corresponding_grid_index[i][j][k].in_x = grid_info.point_con.length - 1;
            }

            if(grid_info.point_con[grid_info.point_con.length - 1].x == canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x){
              path_pos_by_perc[i][j][k].out_x = ((canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x) - grid_info.point_con[grid_info.point_con.length - 1].x) / grid_info.dist_btwn_points
              corresponding_grid_index[i][j][k].out_x = grid_info.point_con.length - 1;
            }


            path_pos_by_perc[i][j][k].y = (path_pos_by_perc[i][j][k].y - canvas_letter.position.y) / canvas_letter.total_height
            path_pos_by_perc[i][j][k].in_y = (path_pos_by_perc[i][j][k].in_y - canvas_letter.position.y) / canvas_letter.total_height
            path_pos_by_perc[i][j][k].out_y = (path_pos_by_perc[i][j][k].out_y - canvas_letter.position.y) / canvas_letter.total_height
        

            // y index is not needed, since the grid is the vertical grid.
            // keeping place holder for y to make the clone process simple, and potential future x&y grid text warp function
            corresponding_grid_index[i][j][k].y = null;
            corresponding_grid_index[i][j][k].in_y = null;
            corresponding_grid_index[i][j][k].out_y = null;

          }
        }
      }




        this.draw_grid = function(path){

          for(let j = 0; j < grid_con_1[path].length; j++){
                            
            // Start a new Path
            ctx.beginPath();
            ctx.moveTo(grid_con_1[path][j].x, grid_con_1[path][j].y);
            ctx.lineTo(grid_con_2[path][j].x, grid_con_2[path][j].y);
            
            // Draw the Path
            ctx.stroke();

          }

        }


        this.draw_letter = function(path){

          ctx.beginPath();

          for(let i = 0; i < path_pos_by_perc.length; i++){
            for(let j = 0; j < path_pos_by_perc[i].length; j++){

              ctx.moveTo(
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).x,
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).y
              );

              for(let k = 0; k < path_pos_by_perc[i][j].length - 1; k++){

                ctx.bezierCurveTo(
                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k].out_x + n], grid_con_2[path][corresponding_grid_index[i][j][k].out_x + 1 + n], path_pos_by_perc[i][j][k].out_x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k].out_x + n], grid_con_1[path][corresponding_grid_index[i][j][k].out_x + 1 + n], path_pos_by_perc[i][j][k].out_x),
                    path_pos_by_perc[i][j][k].out_y
                  ).x,
                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k].out_x + n], grid_con_2[path][corresponding_grid_index[i][j][k].out_x + 1 + n], path_pos_by_perc[i][j][k].out_x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k].out_x + n], grid_con_1[path][corresponding_grid_index[i][j][k].out_x + 1 + n], path_pos_by_perc[i][j][k].out_x),
                    path_pos_by_perc[i][j][k].out_y
                  ).y,

                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k + 1].in_x + n], grid_con_2[path][corresponding_grid_index[i][j][k + 1].in_x + 1 + n], path_pos_by_perc[i][j][k + 1].in_x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k + 1].in_x + n], grid_con_1[path][corresponding_grid_index[i][j][k + 1].in_x + 1 + n], path_pos_by_perc[i][j][k + 1].in_x),
                    path_pos_by_perc[i][j][k + 1].in_y
                  ).x,
                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k + 1].in_x + n], grid_con_2[path][corresponding_grid_index[i][j][k + 1].in_x + 1 + n], path_pos_by_perc[i][j][k + 1].in_x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k + 1].in_x + n], grid_con_1[path][corresponding_grid_index[i][j][k + 1].in_x + 1 + n], path_pos_by_perc[i][j][k + 1].in_x),
                    path_pos_by_perc[i][j][k + 1].in_y
                  ).y,

                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k + 1].x + n], grid_con_2[path][corresponding_grid_index[i][j][k + 1].x + 1 + n], path_pos_by_perc[i][j][k + 1].x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k + 1].x + n], grid_con_1[path][corresponding_grid_index[i][j][k + 1].x + 1 + n], path_pos_by_perc[i][j][k + 1].x),
                    path_pos_by_perc[i][j][k + 1].y
                  ).x,
                  interpolatePoint(
                    interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][k + 1].x + n], grid_con_2[path][corresponding_grid_index[i][j][k + 1].x + 1 + n], path_pos_by_perc[i][j][k + 1].x),
                    interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][k + 1].x + n], grid_con_1[path][corresponding_grid_index[i][j][k + 1].x + 1 + n], path_pos_by_perc[i][j][k + 1].x),
                    path_pos_by_perc[i][j][k + 1].y
                  ).y,
                );

              }

              ctx.bezierCurveTo(

                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + n], grid_con_2[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + 1 + n], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + n], grid_con_1[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + 1 + n], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_y
                ).x,
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + n], grid_con_2[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + 1 + n], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + n], grid_con_1[path][corresponding_grid_index[i][j][path_pos_by_perc[i][j].length - 1].out_x + 1 + n], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_y
                ).y,

                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].in_x + n], grid_con_2[path][corresponding_grid_index[i][j][0].in_x + 1 + n], path_pos_by_perc[i][j][0].in_x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].in_x + n], grid_con_1[path][corresponding_grid_index[i][j][0].in_x + 1 + n], path_pos_by_perc[i][j][0].in_x),
                  path_pos_by_perc[i][j][0].in_y
                ).x,
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].in_x + n], grid_con_2[path][corresponding_grid_index[i][j][0].in_x + 1 + n], path_pos_by_perc[i][j][0].in_x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].in_x + n], grid_con_1[path][corresponding_grid_index[i][j][0].in_x + 1 + n], path_pos_by_perc[i][j][0].in_x),
                  path_pos_by_perc[i][j][0].in_y
                ).y,

                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).x,
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).y,

              );


              ctx.lineTo(

                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].x
                ).x,
                interpolatePoint(
                  interpolatePoint(grid_con_2[path][corresponding_grid_index[i][j][0].x + n], grid_con_2[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].y),
                  interpolatePoint(grid_con_1[path][corresponding_grid_index[i][j][0].x + n], grid_con_1[path][corresponding_grid_index[i][j][0].x + 1 + n], path_pos_by_perc[i][j][0].y),
                  path_pos_by_perc[i][j][0].y
                ).y

              );

            }
          }

          ctx.fillStyle = "#ff0000";
          ctx.fill();
          ctx.closePath();

        }




      function interpolatePoint(point1, point2, t) {
        const x = (1 - t) * point1.x + t * point2.x;
        const y = (1 - t) * point1.y + t * point2.y;
        return {x: x, y: y};
      }


      console.log(grid_info)

        // return {grid_info, path_pos_by_perc, corresponding_grid_index}

    }

    let grid_letter_1 = new Get_Grid_based_Glyph_1(letter_a_1, 800);




/*

Things to tackle

1. Creating grid_con should go in as one of Get_Grid_based_Glyph arguments => Get_Grid_based_Glyph(canvas_letter, grid_shape, num_of_points)
2. Clearly differentiate or merge SingleFontOnCanvas vs StaticSingleFontOnCanvas. I wonder if StaticSingleFontOnCanvas could be SingleFontOnCanvasToBeScanned
3. 


*/


    let path = 3;

    let n = 0;

    function anim() {

        ctx.beginPath();
        ctx.rect(0,0,3000,3000)
        ctx.fillStyle = 'rgba(255,255,255,1)';
        ctx.fillStyle = '#F5A92B';
        ctx.fill();
        ctx.closePath();
        
        // n = n + 2;
        
        grid_letter.draw_grid(3);
        grid_letter.draw_letter(3);

        window.requestAnimationFrame(anim);

    }

    anim();




    </script>
    
  </body>
</html>
