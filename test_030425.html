<html>
  <head>
    <link rel="stylesheet" href="orbit/assets/css/style.css">
  </head>

  <body>

    <canvas id="canvas" width="3000" height="3000"></canvas>

    <script src="path_data/snake_path_0_data.js"></script>
    <script src="path_data/snake_path_1_data.js"></script>
    <script src="path_data/snake_path_2_data.js"></script>
    <script src="path_data/snake_path_3_data.js"></script>

    <script src="beziertools.js"></script>
    <script src="SingleFontOnCanvas/SingleFontOnCanvas.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 55 Roman_data.js"></script>

    <script>
      
    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    ctx.webkitImageSmoothingEnabled = true;
    ctx.mozImageSmoothingEnabled = true;
    ctx.msImageSmoothingEnabled = true;
    ctx.oImageSmoothingEnabled = true;



    
    // let shape_data_con = [snake_path_0, snake_path_1, snake_path_2, snake_path_3];
    
    // console.log(Neue_Haas_Grotesk_Display_Pro_55_Roman)
    // console.log(snake_path_0)

    // // i think this is looping, it needs to add the initial path one additional time as the last path.
    // for(let i = 0; i < shape_data_con.length; i++){
    //   let n = Object.assign({},shape_data_con[i].letters.path[2][0][0]);
    //   shape_data_con[i].letters.path[2][0].push(n)
    // }


    function Close_path(shape){

      for(let i = 0; i < shape.letters.path.length; i++){
        for(let a = 0; a < shape.letters.path[i].length; a++){
          shape.letters.path[i][a].push(shape.letters.path[i][a][0])
        }
      }
      
      return shape
    }

    let closed_snake_path_0 = Close_path(snake_path_0);
    let closed_snake_path_1 = Close_path(snake_path_1);
    let closed_snake_path_2 = Close_path(snake_path_2);
    let closed_snake_path_3 = Close_path(snake_path_3);
    
    let shape_data_con = [closed_snake_path_0, closed_snake_path_1, closed_snake_path_2, closed_snake_path_3];


    // let shape_data_con_1 = [snake_path_0, snake_path_1, snake_path_2, snake_path_3];

    // // i think this is looping, it needs to add the initial path one additional time as the last path.
    // for(let i = 0; i < shape_data_con_1.length; i++){
    //   let n = Object.assign({},shape_data_con_1[i].letters.path[2][0][0]);
    //   shape_data_con_1[i].letters.path[2][0].push(n)
    // }


    console.log(shape_data_con)
    // console.log(shape_data_con_1)

    function Shape_container_arr(shapes, num_of_points, total_grid_amount){


      if(total_grid_amount == undefined){
        total_grid_amount = 1;
      }

      let letter_canvas_path_con = [];

      let bezier_points_con = [];

      let bezier_length = [];

      let divided_length_array_index = [];

      let points_position = [];

      let derivative_angle_con = [];

      let points_angle = [];
      

      for(let i = 0; i < shapes.length; i++){
      
        letter_canvas_path_con[i] = shapes[i].letters.path[2][0];

        for(let a = 0; a < letter_canvas_path_con[i].length; a++){
            letter_canvas_path_con[i][a].y = shapes[i].parameters.cap_height - letter_canvas_path_con[i][a].y;
            letter_canvas_path_con[i][a].in_y = shapes[i].parameters.cap_height - letter_canvas_path_con[i][a].in_y;
            letter_canvas_path_con[i][a].out_y = shapes[i].parameters.cap_height - letter_canvas_path_con[i][a].out_y;
        }

        // console.log(letter_canvas_path_con)

        bezier_points_con[i] = get_bezier_points(letter_canvas_path_con[i]);

        bezier_length[i] = get_bezier_length(bezier_points_con[i]);

        divided_length_array_index[i] = equally_divide_length(bezier_length[i].total_length, bezier_length[i].each_point_length, num_of_points);

        points_position[i] = get_points_position(bezier_points_con[i], divided_length_array_index[i]);

        derivative_angle_con[i] = derivative(bezier_points_con[i]);

        points_angle[i] = get_point_angle(derivative_angle_con[i], divided_length_array_index[i]);

        points_angle[i].pop();

        points_position[i].pop();

      }



      for(let i = 0; i < points_position.length; i++){
        for(let j = 0; j < points_position[i].length; j++){
          points_position[i][j].x = points_position[i][j].x * total_grid_amount
          points_position[i][j].y = points_position[i][j].y * total_grid_amount
        }
      }


    let grid_points_con = [];

    for(let i = 0; i < points_position.length; i++){
      grid_points_con[i] = {grid_a: structuredClone(points_position[i]), grid_b: structuredClone(points_position[i])};
    }


    //this is where you can adjust the angle of path
    //changing the angles to be continuous tangent line
    for(let i = 0; i < points_angle[3].length; i++){
        points_angle[3][i] = points_angle[3][i] * -1
    }

    for(let i = 500; i < 900; i++){
      if(points_angle[3][i] == 0){
        points_angle[3][i] = 90
      }
    }

    for(let i = 0; i < points_angle[0].length; i++){
        points_angle[0][i] = points_angle[0][i] * -1
        points_angle[1][i] = points_angle[1][i] * -1
        points_angle[2][i] = points_angle[2][i] * -1
    }


    for(let i = 100; i < 500; i++){
      if(points_angle[0][i] == 0){
        points_angle[0][i] = 90
      }
    }

    for(let i = 0; i < 130; i++){
      if(points_angle[1][i] == 0){
        points_angle[1][i] = 90
      }
    }

    for(let i = 900; i < 1500; i++){
      if(points_angle[2][i] == 0){
        points_angle[2][i] = 90
      }
    }



    //path width
    for(let i = 0; i < points_position.length; i++){
      for(let j = 0; j < points_position[i].length; j++){

        grid_points_con[i].grid_a[j] = getPointFromAngleAndDistance(
            points_position[i][j].x, points_position[i][j].y, points_angle[i][j], 30
        );

        grid_points_con[i].grid_b[j] = getPointFromAngleAndDistance(
            points_position[i][j].x, points_position[i][j].y, points_angle[i][j], -30
        );

      }
    }
console.log(grid_points_con)
console.log(points_angle)
console.log(grid_points_con)
      return {points_position, points_angle, grid_points_con}
        
    }



    function Shape_container_arr_1(shape, num_of_points, total_grid_amount){

      if(total_grid_amount == undefined){
        total_grid_amount = 1;
      }


      let letter_canvas_path_con = structuredClone(shape.letters.path)

        for(let i = 0; i < shape.letters.path.length; i++){
          for(let a = 0; a < shape.letters.path[i].length; a++){
            for(let n = 0; n < shape.letters.path[i][a].length; n++){
              letter_canvas_path_con[i][a][n].y = shape.parameters.cap_height - shape.letters.path[i][a][n].y;
              letter_canvas_path_con[i][a][n].in_y = shape.parameters.cap_height - shape.letters.path[i][a][n].in_y;
              letter_canvas_path_con[i][a][n].out_y = shape.parameters.cap_height - shape.letters.path[i][a][n].out_y;
            }
          }
        }


      let bezier_points_con = [];

      let bezier_length = [];

      let divided_length_array_index = [];

      let points_position = [];

      let derivative_angle_con = [];

      let points_angle = [];
        

      for(let i = 0; i < letter_canvas_path_con.length; i++){

        bezier_points_con[i] = [];

        bezier_length[i] = [];

        divided_length_array_index[i] = [];

        points_position[i] = [];

        derivative_angle_con[i] = [];

        points_angle[i] = [];


        for(let a = 0; a < letter_canvas_path_con[i].length; a++){

          bezier_points_con[i][a] = get_bezier_points(letter_canvas_path_con[i][a]);

          bezier_length[i][a] = get_bezier_length(bezier_points_con[i][a]);

          divided_length_array_index[i][a] = equally_divide_length(bezier_length[i][a].total_length, bezier_length[i][a].each_point_length, num_of_points);

          points_position[i][a] = get_points_position(bezier_points_con[i][a], divided_length_array_index[i][a]);

          derivative_angle_con[i][a] = derivative(bezier_points_con[i][a]);

          points_angle[i][a] = get_point_angle(derivative_angle_con[i][a], divided_length_array_index[i][a]);

          points_angle[i][a].pop();

          points_position[i][a].pop();

        }
      }

      
      // for(let i = 0; i < points_position.length; i++){
      //   for(let j = 0; j < points_position[i].length; j++){
      //     for(let k = 0; k < points_position[i][j].length; k++){
      //       points_position[i][j][k].x = points_position[i][j][k].x * total_grid_amount
      //       points_position[i][j][k].y = points_position[i][j][k].y * total_grid_amount
      //     }
      //   }
      // }

      // console.log(points_position[0][0][0])
      // console.log(total_grid_amount)


    let grid_points_con = [];

    for(let i = 0; i < points_position.length; i++){
      grid_points_con[i] = [];
      for(let j = 0; j < points_position[i].length; j++){
        grid_points_con[i][j] = [];
        // for(let k = 0; k < points_position[i][j].length; k++){
        //   grid_points_con[i][j][k] = [];
        // }
      }
    }


    for(let i = 0; i < points_position.length; i++){
      for(let j = 0; j < points_position[i].length; j++){
          // for(let k = 0; k < points_position[i][j].length; k++){
            grid_points_con[i][j] = {grid_a: structuredClone(points_position[i][j]), grid_b: structuredClone(points_position[i][j])};
          // }
      }
    }


    //this is where you can adjust the angle of path
    //changing the angles to be continuous tangent line

    for(let i = 0; i < points_angle.length; i++){
      for(let j = 0; j < points_angle[i].length; j++){
        for(let k = 0; k < points_angle[i][j].length; k++){
          points_angle[i][j][k] = points_angle[i][j][k] * -1
        }
      }
    }

    for(let i = 0; i < points_angle.length; i++){
      for(let j = 0; j < points_angle[i].length; j++){
        for(let k = 0; k < points_angle[i][j].length; k++){
          if(points_angle[i][j][k] == 0){
            points_angle[i][j][k] = 90
          }
        }
      }
    }

    // for(let i = 0; i < points_angle.length; i++){
    //   for(let j = 500; j < 900; j++){
    //     if(points_angle[i][j] == 0){
    //       points_angle[i][j] = 90
    //     }
    //   }
    // }

    // for(let i = 0; i < points_angle[0].length; i++){
    //     points_angle[0][i] = points_angle[0][i] * -1
    //     points_angle[1][i] = points_angle[1][i] * -1
    //     points_angle[2][i] = points_angle[2][i] * -1
    // }


    // for(let i = 100; i < 500; i++){
    //   if(points_angle[0][i] == 0){
    //     points_angle[0][i] = 90
    //   }
    // }

    // for(let i = 0; i < 130; i++){
    //   if(points_angle[1][i] == 0){
    //     points_angle[1][i] = 90
    //   }
    // }

    // for(let i = 900; i < 1500; i++){
    //   if(points_angle[2][i] == 0){
    //     points_angle[2][i] = 90
    //   }
    // }



    //path width
    for(let i = 0; i < grid_points_con.length; i++){
      for(let j = 0; j < grid_points_con[i].length; j++){
        for(let k = 0; k < grid_points_con[i][j].length; k++){

          grid_points_con[i][j].grid_a[k] = getPointFromAngleAndDistance(
              points_position[i][j][k].x, points_position[i][j][k].y, points_angle[i][j][k], 30
          );

          grid_points_con[i][j].grid_b[k] = getPointFromAngleAndDistance(
              points_position[i][j][k].x, points_position[i][j][k].y, points_angle[i][j][k], -30
          );

        }
      }
    }

      return {points_position, points_angle, grid_points_con}
        
    }




    let num_of_points = 1500;

    let shape_con = new Shape_container_arr(shape_data_con, num_of_points, 1);

    let shape_con_0 = new Shape_container_arr_1(closed_snake_path_0, num_of_points, 1, snake_path_0);
    let shape_con_1 = new Shape_container_arr_1(closed_snake_path_1, num_of_points, 1, snake_path_0);
    let shape_con_2 = new Shape_container_arr_1(closed_snake_path_2, num_of_points, 1, snake_path_0);
    let shape_con_3 = new Shape_container_arr_1(closed_snake_path_3, num_of_points, 1, snake_path_0);



    function getPointFromAngleAndDistance(x, y, angle, length) {

        // Convert angle from degrees to radians
        let radians = angle * (Math.PI / 180);

        // Calculate the new x and y positions
        let newX = x + length * Math.cos(radians);
        let newY = y + length * Math.sin(radians);

        return { x: newX, y: newY };

    }

    let letter_a_1 = new StaticSingleFontOnCanvas(Neue_Haas_Grotesk_Display_Pro_55_Roman, 'asd');




    function Get_Grid_based_Glyph(canvas_letter, num_of_points){

      console.log(canvas_letter)

      let grid_info = {
        num_of_points: num_of_points,
        dist_btwn_points: null,
        point_con: []
      }

      // Calculate the distance between grid points based on the letter's dimensions(width)
      if((canvas_letter.extreme_val.max - canvas_letter.position.x) > canvas_letter.total_width){
          grid_info.dist_btwn_points = (canvas_letter.extreme_val.max - canvas_letter.position.x) / grid_info.num_of_points;
      }else{
          grid_info.dist_btwn_points = canvas_letter.total_width / grid_info.num_of_points;
      }

      // Populate the grid points with calculated distances
      for(let i = 0; i <= grid_info.num_of_points; i++){
          grid_info.point_con[i] = {x: grid_info.dist_btwn_points * i , y: 0};
      }


      //  Finding points percentage within the grid for interpolation
      let path_pos_by_perc = structuredClone(canvas_letter.typeface_path_con);

      //  Finding which grid the points lies on
      let corresponding_grid_index = structuredClone(canvas_letter.typeface_path_con);


      for(let i = 0; i < canvas_letter.typeface_path_con.length; i++){
        for(let j = 0; j < canvas_letter.typeface_path_con[i].length; j++){
          for(let k = 0; k < canvas_letter.typeface_path_con[i][j].length; k++){

            for(let n = 0; n < grid_info.point_con.length - 1; n++){

              if(grid_info.point_con[n].x <= canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x && canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x < grid_info.point_con[n + 1].x){
                path_pos_by_perc[i][j][k].x = ((canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x) - grid_info.point_con[n].x) / grid_info.dist_btwn_points
                corresponding_grid_index[i][j][k].x = n;
              }

              if(grid_info.point_con[n].x <= canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x && canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x < grid_info.point_con[n + 1].x){
                path_pos_by_perc[i][j][k].in_x = ((canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x) - grid_info.point_con[n].x) / grid_info.dist_btwn_points
                corresponding_grid_index[i][j][k].in_x = n;
              }

              if(grid_info.point_con[n].x <= canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x && canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x < grid_info.point_con[n + 1].x){
                path_pos_by_perc[i][j][k].out_x = ((canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x) - grid_info.point_con[n].x) / grid_info.dist_btwn_points
                corresponding_grid_index[i][j][k].out_x = n;
              }

            }         


            if(grid_info.point_con[grid_info.point_con.length - 1].x == canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x){
              path_pos_by_perc[i][j][k].x = ((canvas_letter.typeface_path_con[i][j][k].x - canvas_letter.position.x) - grid_info.point_con[grid_info.point_con.length - 1].x) / grid_info.dist_btwn_points
              corresponding_grid_index[i][j][k].x = grid_info.point_con.length - 1;
            }

            if(grid_info.point_con[grid_info.point_con.length - 1].x == canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x){
              path_pos_by_perc[i][j][k].in_x = ((canvas_letter.typeface_path_con[i][j][k].in_x - canvas_letter.position.x) - grid_info.point_con[grid_info.point_con.length - 1].x) / grid_info.dist_btwn_points
              corresponding_grid_index[i][j][k].in_x = grid_info.point_con.length - 1;
            }

            if(grid_info.point_con[grid_info.point_con.length - 1].x == canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x){
              path_pos_by_perc[i][j][k].out_x = ((canvas_letter.typeface_path_con[i][j][k].out_x - canvas_letter.position.x) - grid_info.point_con[grid_info.point_con.length - 1].x) / grid_info.dist_btwn_points
              corresponding_grid_index[i][j][k].out_x = grid_info.point_con.length - 1;
            }


            path_pos_by_perc[i][j][k].y = (path_pos_by_perc[i][j][k].y - canvas_letter.position.y) / canvas_letter.total_height
            path_pos_by_perc[i][j][k].in_y = (path_pos_by_perc[i][j][k].in_y - canvas_letter.position.y) / canvas_letter.total_height
            path_pos_by_perc[i][j][k].out_y = (path_pos_by_perc[i][j][k].out_y - canvas_letter.position.y) / canvas_letter.total_height
        

            // y index is not needed, since the grid is the vertical grid.
            // keeping place holder for y to make the clone process simple, and potential future x&y grid text warp function
            corresponding_grid_index[i][j][k].y = null;
            corresponding_grid_index[i][j][k].in_y = null;
            corresponding_grid_index[i][j][k].out_y = null;

          }
        }
      }

      // console.log('canvas_letter.typeface_path_con')
      // console.log(canvas_letter.typeface_path_con)
      // console.log('path_pos_by_perc')
      // console.log(path_pos_by_perc)
      // console.log('corresponding_grid_index')
      // console.log(corresponding_grid_index)

        

      let corresponding_grid_index_ahead = structuredClone(corresponding_grid_index);


      for(let i = 0 ; i < corresponding_grid_index_ahead.length; i++){
        for(let j = 0 ; j < corresponding_grid_index_ahead[i].length; j++){
          for(let k = 0 ; k < corresponding_grid_index_ahead[i][j].length; k++){

            corresponding_grid_index_ahead[i][j][k].x = corresponding_grid_index_ahead[i][j][k].x + 1;
            corresponding_grid_index_ahead[i][j][k].in_x = corresponding_grid_index_ahead[i][j][k].in_x + 1;
            corresponding_grid_index_ahead[i][j][k].out_x = corresponding_grid_index_ahead[i][j][k].out_x + 1;

          }
        }
      }

      // console.log(corresponding_grid_index)
      // console.log(corresponding_grid_index_ahead)

      let grid_index_for_background = Find_min_max_grid_index_for_each_letter(corresponding_grid_index)


    function Find_min_max_grid_index_for_each_letter(grid_index){

      let each_letter_index_con = [];

      for(let i = 0; i < grid_index.length; i++){
        each_letter_index_con[i] = {min: null, max: null};
      }


      for(let i = 0; i < grid_index.length; i++){
          
        let flattened = grid_index[i].flat();

        let combinedValues = flattened.reduce((arr, item) => {
            arr.push(item.x, item.in_x, item.out_x);
            return arr;
        }, []);

        each_letter_index_con[i].min = Math.min(...combinedValues);
        each_letter_index_con[i].max = Math.max(...combinedValues);

      }


      for(let i = 0; i < each_letter_index_con.length - 1; i++){
        each_letter_index_con[i].max = each_letter_index_con[i+1].min - 1
      }


      return each_letter_index_con

    }


    


        this.draw_grid = function(path){
          
          for(let i = 0; i < path.grid_a.length; i++){
            // Start a new Path
            ctx.beginPath();
            ctx.moveTo(path.grid_a[i].x, path.grid_a[i].y);
            ctx.lineTo(path.grid_b[i].x, path.grid_b[i].y);
  
            // Draw the Path
            ctx.stroke();
          }

          
        }


        this.draw_letter = function(path, total_grid_amount, color, background_color){

          ctx.beginPath();
          
          // for(let x = 0; x < 3; x++){

          for(let i = 0; i < path_pos_by_perc.length; i++){

            //animation value
            grid_index_for_background[i].min = grid_index_for_background[i].min + 1
            grid_index_for_background[i].max = grid_index_for_background[i].max + 1

            if(grid_index_for_background[i].min >= total_grid_amount){
              grid_index_for_background[i].min = 0;
            }
            
            if(grid_index_for_background[i].max >= total_grid_amount){
              grid_index_for_background[i].max = 0;
            }
            
                

            for(let j = 0; j < path_pos_by_perc[i].length; j++){
              for(let k = 0; k < path_pos_by_perc[i][j].length; k++){

                //animation value

                corresponding_grid_index_ahead[i][j][k].x = corresponding_grid_index_ahead[i][j][k].x + 1;
                corresponding_grid_index_ahead[i][j][k].out_x = corresponding_grid_index_ahead[i][j][k].out_x + 1;
                corresponding_grid_index_ahead[i][j][k].in_x = corresponding_grid_index_ahead[i][j][k].in_x + 1;



                if(corresponding_grid_index_ahead[i][j][k].x >= total_grid_amount){
                  corresponding_grid_index_ahead[i][j][k].x = 0;
                }
                if(corresponding_grid_index_ahead[i][j][k].in_x >= total_grid_amount){
                  corresponding_grid_index_ahead[i][j][k].in_x = 0;
                }
                if(corresponding_grid_index_ahead[i][j][k].out_x >= total_grid_amount){
                  corresponding_grid_index_ahead[i][j][k].out_x = 0;
                }


                
                corresponding_grid_index[i][j][k].x = corresponding_grid_index[i][j][k].x + 1;
                corresponding_grid_index[i][j][k].out_x = corresponding_grid_index[i][j][k].out_x + 1;
                corresponding_grid_index[i][j][k].in_x = corresponding_grid_index[i][j][k].in_x + 1;


                if(corresponding_grid_index[i][j][k].x >= total_grid_amount){
                  corresponding_grid_index[i][j][k].x = 0;
                }
                if(corresponding_grid_index[i][j][k].in_x >= total_grid_amount){
                  corresponding_grid_index[i][j][k].in_x = 0;
                }
                if(corresponding_grid_index[i][j][k].out_x >= total_grid_amount){
                  corresponding_grid_index[i][j][k].out_x = 0;
                }


              }

            }
          }
        // }
          


          
          for(let i = 0; i < path_pos_by_perc.length; i++){

            //if it hits the second last point or 1 before hits 0
           if(grid_index_for_background[i].max >= total_grid_amount - 2){

                for(let n = grid_index_for_background[i].min; n < total_grid_amount - 2; n++){

                  ctx.beginPath();
                  ctx.moveTo(path.grid_a[n].x, path.grid_a[n].y);
                  ctx.lineTo(path.grid_a[n + 1].x, path.grid_a[n + 1].y);
                  ctx.lineTo(path.grid_a[n + 2].x, path.grid_a[n + 2].y);
                  ctx.lineTo(path.grid_b[n + 2].x, path.grid_b[n + 2].y);
                  ctx.lineTo(path.grid_b[n + 1].x, path.grid_b[n + 1].y);
                  ctx.lineTo(path.grid_b[n].x, path.grid_b[n].y);
                  ctx.lineTo(path.grid_a[n].x, path.grid_a[n].y);

                  ctx.fillStyle = background_color;
                  
                  ctx.fill();
                  ctx.closePath();

                }

                  ctx.beginPath();

                  ctx.moveTo(path.grid_a[total_grid_amount - 2].x, path.grid_a[total_grid_amount - 2].y);
                  ctx.lineTo(path.grid_a[total_grid_amount - 1].x, path.grid_a[total_grid_amount - 1].y);
                  ctx.lineTo(path.grid_a[0].x, path.grid_a[0].y);
                  ctx.lineTo(path.grid_b[0].x, path.grid_b[0].y);
                  ctx.lineTo(path.grid_b[total_grid_amount - 1].x, path.grid_b[total_grid_amount - 1].y);
                  ctx.lineTo(path.grid_b[total_grid_amount - 2].x, path.grid_b[total_grid_amount - 2].y);
                  ctx.lineTo(path.grid_a[total_grid_amount - 2].x, path.grid_a[total_grid_amount - 1].y);

                  ctx.fillStyle = background_color;
                  
                  ctx.fill();
                  ctx.closePath();

              }else if(grid_index_for_background[i].max >= total_grid_amount - 1){


                for(let n = grid_index_for_background[i].min; n < total_grid_amount - 1; n++){

                  ctx.beginPath();

                  ctx.moveTo(path.grid_a[n].x, path.grid_a[n].y);
                  ctx.lineTo(path.grid_a[n + 1].x, path.grid_a[n + 1].y);
                  ctx.lineTo(path.grid_b[n + 1].x, path.grid_b[n + 1].y);
                  ctx.lineTo(path.grid_b[n].x, path.grid_b[n].y);
                  ctx.lineTo(path.grid_a[n].x, path.grid_a[n].y);

                  ctx.fillStyle = background_color;
                  
                  ctx.fill();
                  ctx.closePath();

                }

                  ctx.beginPath();

                  ctx.moveTo(path.grid_a[total_grid_amount - 2].x, path.grid_a[total_grid_amount - 2].y);
                  ctx.lineTo(path.grid_a[total_grid_amount - 1].x, path.grid_a[total_grid_amount - 1].y);
                  ctx.lineTo(path.grid_a[0].x, path.grid_a[0].y);
                  ctx.lineTo(path.grid_b[0].x, path.grid_b[0].y);
                  ctx.lineTo(path.grid_b[total_grid_amount - 1].x, path.grid_b[total_grid_amount - 1].y);
                  ctx.lineTo(path.grid_b[total_grid_amount - 2].x, path.grid_b[total_grid_amount - 2].y);
                  ctx.lineTo(path.grid_a[total_grid_amount - 2].x, path.grid_a[total_grid_amount - 1].y);

                  ctx.fillStyle = background_color;
                  
                  ctx.fill();
                  ctx.closePath();

              }else if(grid_index_for_background[i].max < grid_index_for_background[i].min){


                for(let n = grid_index_for_background[i].min; n < total_grid_amount - 2; n++){

                  ctx.beginPath();

                  ctx.moveTo(path.grid_a[n].x, path.grid_a[n].y);
                  ctx.lineTo(path.grid_a[n + 1].x, path.grid_a[n + 1].y);
                  ctx.lineTo(path.grid_a[n + 2].x, path.grid_a[n + 2].y);
                  ctx.lineTo(path.grid_b[n + 2].x, path.grid_b[n + 2].y);
                  ctx.lineTo(path.grid_b[n + 1].x, path.grid_b[n + 1].y);
                  ctx.lineTo(path.grid_b[n].x, path.grid_b[n].y);
                  ctx.lineTo(path.grid_a[n].x, path.grid_a[n].y);

                  ctx.fillStyle = background_color;
                  
                  ctx.fill();
                  ctx.closePath();

                }

                  ctx.beginPath();

                  ctx.moveTo(path.grid_a[total_grid_amount - 2].x, path.grid_a[total_grid_amount - 2].y);
                  ctx.lineTo(path.grid_a[total_grid_amount - 1].x, path.grid_a[total_grid_amount - 1].y);
                  ctx.lineTo(path.grid_a[0].x, path.grid_a[0].y);
                  ctx.lineTo(path.grid_b[0].x, path.grid_b[0].y);
                  ctx.lineTo(path.grid_b[total_grid_amount - 1].x, path.grid_b[total_grid_amount - 1].y);
                  ctx.lineTo(path.grid_b[total_grid_amount - 2].x, path.grid_b[total_grid_amount - 2].y);
                  ctx.lineTo(path.grid_a[total_grid_amount - 2].x, path.grid_a[total_grid_amount - 1].y);

                  ctx.fillStyle = background_color;
                  
                  ctx.fill();
                  ctx.closePath();


                for(let n = 0; n <= grid_index_for_background[i].max; n++){

                  ctx.beginPath();

                  ctx.moveTo(path.grid_a[n].x, path.grid_a[n].y);
                  ctx.lineTo(path.grid_a[n + 1].x, path.grid_a[n + 1].y);
                  ctx.lineTo(path.grid_a[n + 2].x, path.grid_a[n + 2].y);
                  ctx.lineTo(path.grid_b[n + 2].x, path.grid_b[n + 2].y);
                  ctx.lineTo(path.grid_b[n + 1].x, path.grid_b[n + 1].y);
                  ctx.lineTo(path.grid_b[n].x, path.grid_b[n].y);
                  ctx.lineTo(path.grid_a[n].x, path.grid_a[n].y);

                  ctx.fillStyle = background_color;
                  
                  ctx.fill();
                  ctx.closePath();

                }

              }else{

                for(let n = grid_index_for_background[i].min; n <= grid_index_for_background[i].max; n++){

                  ctx.beginPath();

                  ctx.moveTo(path.grid_a[n].x, path.grid_a[n].y);
                  ctx.lineTo(path.grid_a[n + 1].x, path.grid_a[n + 1].y);
                  ctx.lineTo(path.grid_a[n + 2].x, path.grid_a[n + 2].y);
                  ctx.lineTo(path.grid_b[n + 2].x, path.grid_b[n + 2].y);
                  ctx.lineTo(path.grid_b[n + 1].x, path.grid_b[n + 1].y);
                  ctx.lineTo(path.grid_b[n].x, path.grid_b[n].y);
                  ctx.lineTo(path.grid_a[n].x, path.grid_a[n].y);
                  
                  ctx.fillStyle = background_color;
                  ctx.fill();

                  ctx.closePath();
                  

                }

              }



              
            


            ctx.beginPath();

            for(let j = 0; j < path_pos_by_perc[i].length; j++){
              
              ctx.moveTo(
                interpolatePoint(
                  interpolatePoint(path.grid_b[corresponding_grid_index[i][j][0].x], path.grid_b[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(path.grid_a[corresponding_grid_index[i][j][0].x], path.grid_a[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).x,
                interpolatePoint(
                  interpolatePoint(path.grid_b[corresponding_grid_index[i][j][0].x], path.grid_b[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(path.grid_a[corresponding_grid_index[i][j][0].x], path.grid_a[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).y
              );

              for(let k = 0; k < path_pos_by_perc[i][j].length - 1; k++){

                ctx.bezierCurveTo(
                  interpolatePoint(
                    interpolatePoint(path.grid_b[corresponding_grid_index[i][j][k].out_x], path.grid_b[corresponding_grid_index_ahead[i][j][k].out_x], path_pos_by_perc[i][j][k].out_x),
                    interpolatePoint(path.grid_a[corresponding_grid_index[i][j][k].out_x], path.grid_a[corresponding_grid_index_ahead[i][j][k].out_x], path_pos_by_perc[i][j][k].out_x),
                    path_pos_by_perc[i][j][k].out_y
                  ).x,
                  interpolatePoint(
                    interpolatePoint(path.  grid_b[corresponding_grid_index[i][j][k].out_x], path.grid_b[corresponding_grid_index_ahead[i][j][k].out_x], path_pos_by_perc[i][j][k].out_x),
                    interpolatePoint(path.grid_a[corresponding_grid_index[i][j][k].out_x], path.grid_a[corresponding_grid_index_ahead[i][j][k].out_x], path_pos_by_perc[i][j][k].out_x),
                    path_pos_by_perc[i][j][k].out_y
                  ).y,

                  interpolatePoint(
                    interpolatePoint(path.grid_b[corresponding_grid_index[i][j][k + 1].in_x], path.grid_b[corresponding_grid_index_ahead[i][j][k + 1].in_x], path_pos_by_perc[i][j][k + 1].in_x),
                    interpolatePoint(path.grid_a[corresponding_grid_index[i][j][k + 1].in_x], path.grid_a[corresponding_grid_index_ahead[i][j][k + 1].in_x], path_pos_by_perc[i][j][k + 1].in_x),
                    path_pos_by_perc[i][j][k + 1].in_y
                  ).x,
                  interpolatePoint(
                    interpolatePoint(path.grid_b[corresponding_grid_index[i][j][k + 1].in_x], path.grid_b[corresponding_grid_index_ahead[i][j][k + 1].in_x], path_pos_by_perc[i][j][k + 1].in_x),
                    interpolatePoint(path.grid_a[corresponding_grid_index[i][j][k + 1].in_x], path.grid_a[corresponding_grid_index_ahead[i][j][k + 1].in_x], path_pos_by_perc[i][j][k + 1].in_x),
                    path_pos_by_perc[i][j][k + 1].in_y
                  ).y,

                  interpolatePoint(
                    interpolatePoint(path.grid_b[corresponding_grid_index[i][j][k + 1].x], path.grid_b[corresponding_grid_index_ahead[i][j][k + 1].x], path_pos_by_perc[i][j][k + 1].x),
                    interpolatePoint(path.grid_a[corresponding_grid_index[i][j][k + 1].x], path.grid_a[corresponding_grid_index_ahead[i][j][k + 1].x], path_pos_by_perc[i][j][k + 1].x),
                    path_pos_by_perc[i][j][k + 1].y
                  ).x,
                  interpolatePoint(
                    interpolatePoint(path.grid_b[corresponding_grid_index[i][j][k + 1].x], path.grid_b[corresponding_grid_index_ahead[i][j][k + 1].x], path_pos_by_perc[i][j][k + 1].x),
                    interpolatePoint(path.grid_a[corresponding_grid_index[i][j][k + 1].x], path.grid_a[corresponding_grid_index_ahead[i][j][k + 1].x], path_pos_by_perc[i][j][k + 1].x),
                    path_pos_by_perc[i][j][k + 1].y
                  ).y,
                );

              }

              ctx.bezierCurveTo(

                interpolatePoint(
                  interpolatePoint(path.grid_b[corresponding_grid_index[i][j][corresponding_grid_index[i][j].length - 1].out_x], path.grid_b[corresponding_grid_index_ahead[i][j][corresponding_grid_index[i][j].length - 1].out_x], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  interpolatePoint(path.grid_a[corresponding_grid_index[i][j][corresponding_grid_index[i][j].length - 1].out_x], path.grid_a[corresponding_grid_index_ahead[i][j][corresponding_grid_index[i][j].length - 1].out_x], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_y
                ).x,
                interpolatePoint(
                  interpolatePoint(path.grid_b[corresponding_grid_index[i][j][corresponding_grid_index[i][j].length - 1].out_x], path.grid_b[corresponding_grid_index_ahead[i][j][corresponding_grid_index[i][j].length - 1].out_x], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  interpolatePoint(path.grid_a[corresponding_grid_index[i][j][corresponding_grid_index[i][j].length - 1].out_x], path.grid_a[corresponding_grid_index_ahead[i][j][corresponding_grid_index[i][j].length - 1].out_x], path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_x),
                  path_pos_by_perc[i][j][path_pos_by_perc[i][j].length - 1].out_y
                ).y,

                interpolatePoint(
                  interpolatePoint(path.grid_b[corresponding_grid_index[i][j][0].in_x], path.grid_b[corresponding_grid_index_ahead[i][j][0].in_x], path_pos_by_perc[i][j][0].in_x),
                  interpolatePoint(path.grid_a[corresponding_grid_index[i][j][0].in_x], path.grid_a[corresponding_grid_index_ahead[i][j][0].in_x], path_pos_by_perc[i][j][0].in_x),
                  path_pos_by_perc[i][j][0].in_y
                ).x,
                interpolatePoint(
                  interpolatePoint(path.grid_b[corresponding_grid_index[i][j][0].in_x], path.grid_b[corresponding_grid_index_ahead[i][j][0].in_x], path_pos_by_perc[i][j][0].in_x),
                  interpolatePoint(path.grid_a[corresponding_grid_index[i][j][0].in_x], path.grid_a[corresponding_grid_index_ahead[i][j][0].in_x], path_pos_by_perc[i][j][0].in_x),
                  path_pos_by_perc[i][j][0].in_y
                ).y,

                interpolatePoint(
                  interpolatePoint(path.grid_b[corresponding_grid_index[i][j][0].x], path.grid_b[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(path.grid_a[corresponding_grid_index[i][j][0].x], path.grid_a[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).x,
                interpolatePoint(
                  interpolatePoint(path.grid_b[corresponding_grid_index[i][j][0].x], path.grid_b[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(path.grid_a[corresponding_grid_index[i][j][0].x], path.grid_a[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).y,

              );


              ctx.lineTo(
              interpolatePoint(
                  interpolatePoint(path.grid_b[corresponding_grid_index[i][j][0].x], path.grid_b[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(path.grid_a[corresponding_grid_index[i][j][0].x], path.grid_a[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).x,
                interpolatePoint(
                  interpolatePoint(path.grid_b[corresponding_grid_index[i][j][0].x], path.grid_b[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  interpolatePoint(path.grid_a[corresponding_grid_index[i][j][0].x], path.grid_a[corresponding_grid_index_ahead[i][j][0].x], path_pos_by_perc[i][j][0].x),
                  path_pos_by_perc[i][j][0].y
                ).y
              );


            }

            ctx.fillStyle = color;

              ctx.fill();
              ctx.closePath();



          }


        }

        let point_a = 0;
        let point_b = 200;

        this.draw_shape = function(path){

          point_a++
          point_b++

          if(point_a >= 499){
            point_a = 0;
          }
          // console.log(point_a)

          if(point_b >= 499){
            point_b = 0;
          }

          ctx.beginPath();
            ctx.moveTo(path.grid_a[point_a].x, path.grid_a[point_a].y);

          for(let i = point_a; i < point_b; i++){
            // Start a new Path
            ctx.lineTo(path.grid_a[i].x, path.grid_a[i].y);
  
          }

          for(let i = point_b; i >= point_a; i--){
            ctx.lineTo(path.grid_b[i].x, path.grid_b[i].y);
          }

          // ctx.lineTo(path.grid_a[path.grid_a.length - 1].x, path.grid_a[path.grid_a.length - 1].y);

          ctx.lineTo(path.grid_a[point_a].x, path.grid_a[point_a].y);

          ctx.fillStyle = "#000000";
          ctx.fill();
          ctx.closePath();

        }

        
      function interpolatePoint(point1, point2, t) {
        const x = (1 - t) * point1.x + t * point2.x;
        const y = (1 - t) * point1.y + t * point2.y;
        return {x: x, y: y};
      }


    }

    let grid_letter = new Get_Grid_based_Glyph(letter_a_1, 100);
    
    let total_grid_amount = 1500

console.log(shape_con.grid_points_con[0])

console.log(shape_con_0.grid_points_con[2][0])

    function anim() {


        ctx.beginPath();
        ctx.rect(0,0,3000,3000)
        ctx.fillStyle = 'rgba(255,255,255,1)';
        ctx.fillStyle = '#E5E4DE';
        ctx.fill();
        ctx.closePath();
        
        

        grid_letter.draw_grid(shape_con.grid_points_con[0]);
        // grid_letter.draw_shape(shape_con.grid_points_con[0]);
        grid_letter.draw_letter(shape_con.grid_points_con[0], total_grid_amount, 'black', 'red');


        window.requestAnimationFrame(anim);

    }

    anim();



    </script>
    
  </body>
</html>
